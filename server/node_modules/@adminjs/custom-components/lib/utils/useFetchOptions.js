"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFetchOptions = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
const adminjs_1 = require("adminjs");
const react_redux_1 = require("react-redux");
const react_1 = require("react");
const useFetchOptions = ({ record, resourceId, searchProperty, filters, selectedIds, }) => {
    const user = (0, react_redux_1.useSelector)(s => s.session);
    const parseFilters = getFilterParser(user, record);
    const [cache, setCache] = (0, react_1.useState)({});
    const [error, setError] = (0, react_1.useState)(null);
    const search = async (input) => {
        var _a, _b, _c, _d, _e, _f, _g;
        try {
            const response = await new adminjs_1.ApiClient().resourceAction({
                resourceId,
                actionName: 'list',
                params: Object.assign(Object.assign({ perPage: Number.MAX_SAFE_INTEGER }, parseFilters(filters)), { [`filters.${searchProperty}`]: input }),
            });
            const incomingRecords = ((_d = (_c = (_b = (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.records) === null || _b === void 0 ? void 0 : _b.filter) === null || _c === void 0 ? void 0 : _c.call(_b, r => r.id !== record.id)) !== null && _d !== void 0 ? _d : []);
            setCache(prev => {
                const copy = Object.assign({}, prev);
                incomingRecords.forEach(r => {
                    copy[r.id] = r;
                });
                return copy;
            });
            return incomingRecords;
        }
        catch (e) {
            setError((_g = (_f = (_e = e.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.message) !== null && _g !== void 0 ? _g : e.message);
            return [];
        }
    };
    (0, react_1.useEffect)(() => {
        const getOption = async (id) => {
            if (cache[id]) {
                return;
            }
            const result = await new adminjs_1.ApiClient().recordAction({
                resourceId,
                recordId: id,
                actionName: 'show',
            });
            const r = result.data.record;
            if (r) {
                setCache(prev => (Object.assign(Object.assign({}, prev), { [r.id]: r })));
            }
        };
        selectedIds.forEach(getOption);
    }, [cache, resourceId, selectedIds]);
    return {
        search,
        error,
        selected: Object.values(cache).filter(c => selectedIds.includes(c.id)),
    };
};
exports.useFetchOptions = useFetchOptions;
const getFilterParser = (user, record) => (filters) => {
    const results = {};
    Object.entries(filters).forEach(([key, filter]) => {
        var _a;
        switch (filter.type) {
            case 'owner': {
                const { source } = filter;
                const value = (_a = (source
                    ? record.params[source]
                    : undefined)) !== null && _a !== void 0 ? _a : user.id;
                results[`filters.${key}`] = value;
                break;
            }
            case 'reference': {
                const { field } = filter;
                const value = record.params[field];
                if (!value) {
                    throw new Error(`Fill "${field} field first"`);
                }
                results[`filters.${key}`] = value;
                break;
            }
            case 'string': {
                const { value } = filter;
                results[`filters.${key}`] = value;
                break;
            }
            default: {
                throw new Error('Incorrect filter type');
            }
        }
    });
    return results;
};
